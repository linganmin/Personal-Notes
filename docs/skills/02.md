# 性能&并发

## Swoole 和 PHP-FPM 的相同和不同之处

> Swoole 和 FPM 都是基于服务器提升 PHP `解析性能`的方案，进程模型是相同的。

### 相同

- 一个 manager 多个 worker
- manager 负责管理接收请求数据，转发数据，管理子进程（拉起和关闭）
- worker 负责处理请求数据

### 不同

- FPM 的 worker 进程是同步阻塞的，Swoole 的 worker 进程是异步非阻塞的
- Swoole http-server 和 FPM 的差异是后者是常住内存的，PHP 程序变成长生命周期，变量和对象在使用请求后不会被销毁，可以复用

:::tip
在 WEB 流程中，最早使用 cgi 协议用于server的通讯，这种方式会导致高并发情况下，会频繁创建、销毁进程，影响性能。之后出现了 fast-cgi ，采用多进程（进程池）来管理，避免进程频繁销毁。后来随着各种复杂的框架（比如 Laravel）的出现，使得每次请求时框架在初始化过程中会频繁创建大量对象，这又在一定程度上会影响性能，所以就出现了 Swoole 这种基于 PHP 的 http-server，可以将 PHP 对象的声明周期常驻内存，避免了重复创建、销毁大量 PHP 对象。（基于 Swoole 的 http-server 可能会导致一些内存泄漏）
:::

## 接口设计：RESETFUL

## 接口设计：幂等

- 幂等概念
  - 保证唯一
- 产生原因
  - rpc 调用时网络延迟（重试发送请求）
  - 表单重复提交

幂等性是系统的接口对外的一种承诺，而不是实现。承诺只要调用接口成功，外部多次调用对系统的影响是一致的，声明为幂等的接口会认为外部调用失败是常态，并且失败之后必然会有重试。

有些接口是天然实现幂等性的，比如查询接口。对于查询接口，你查询一次和两次，对于系统来说没有任何影响，查出的结果是一样的。

### 对增加、删除、更新操作做幂等处理

- 全局唯一 id

根据业务和操作的内容生成一个全局 id，在执行操作以先判断存储系统中是否存在这个全局 id 来判断这个操作是否已经执行。如果不存在则把全局 id，存到存储系统中，如果存在则表示该操作已经执行。

高可靠的幂等服务。

- 去重表

新建一张去重表（唯一键），在接口操作数据的事务中增加将唯一标识（比如订单 id）写入去重表，如果重复创建数据库会跑出唯一约束异常，操作就会回滚。

比如在支付场景中，如果一个订单只会支付一次，所以订单 ID 可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和订单号写入去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。

- 插入或更新

通过数据库唯一键，实现 createOrUpdate 操作

## 高并发下的数据处理

### 缓存

- 更新策略

- 缓存穿透 || 缓存雪崩

## 换算QBS->机器