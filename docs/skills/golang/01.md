# Golang

## panic 和 defer

### panic

`panic`可以直接从代码初始化：当错误条件很严苛且不可恢复，程序不能继续运行时，可以使用`panic`函数产生一个中止程序的运行时错误。`panic`接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。不能随意地用`panic`中止程序，必须尽力补救错误让程序能继续执行。

### recover

`recover`内建函数被用于从`panic`或错误场景中恢复：让程序可以从`panicking`重新获得控制权，停止终止过程进而恢复正常执行。

`recover`只能在`defer`修饰的函数中使用，用于取得`panic`调用中传递过来的错误值，如果是正常执行，调用`recover`会返回`nil`，且没有其它效果。

> `panic`会导致栈被展开直到`defer`修饰的`recover`被调用或者程序中止

### 如果在一个 goroutine 里面发生的 panic，这个错误能捕捉吗

- `panic` 会停止整个进程，不仅仅是当前`goroutine`，也就是说整个程序都会凉凉
- `panic`是有序的、可控的停止程序，不是啪唧一下就宕掉了，所以我们还可以用`recover`补救
- `recover`只能在`defer`里面生效，如果不是在`defer`里调用，会直接返回`nil`
- 很重要的一点是：`goroutine`发生`panic`时，只会调用自身的`defer`，所以即便主`goroutine`里写了`recover`逻辑，也无法拯救到其它`goroutine`里的`panic`
