# 编写可读代码的艺术

## 1.代码应当易于理解

## 2.把信息装到名字里

## 3.不会误解的名字

## 4.审美

## 5.该写什么样的注释

## 6.写出言简意赅的注释

## 7.把控制流变得易读

## 8.拆分超长的表达式

## 9.变量与可读性

本章主要讲了三个问题

- 变量越多，就越难全部跟踪他们的动向
- 变量作用域越大，就需要跟踪它的动向越久
- 变量改变的越频繁，就越难跟踪他当前的值

### 减少变量

- 减少没有价值的临时变量

  ```php
  // ...

  $now = date('Y-m-d H:i:s');

  $user->updated_at = $now;

  // ...
  ```

  对于这种没有拆分任何复杂表达式，也没有做更多解释，只用过一次的变量，是没有必要的。

  ```php
  // ...

  $user->updated_at = date('Y-m-d H:i:s');

  // ...
  ```

- 减少中间结果

  ```js
  // 更改前
  var remove_one = function(array, value_to_remove) {
    let index_to_remove = null

    for (let i = 0; i < array.length; i++) {
      if (array[i] === value_to_remove) {
        index_to_remove = i
      }
    }
    if (index_to_remove !== null) {
      array.splice(index_to_remove, 1)
    }
  }

  // 更改后
  var remove_one = function(array, value_to_remove) {
    let index_to_remove = null

    for (let i = 0; i < array.length; i++) {
      if (array[i] === value_to_remove) {
        array.splice(i, 1) // 这里不去增加临时变量保存需要删除的index，可以直接处理掉
      }
    }
  }
  ```

- 减少控制流转变量

  ```php

  // 修改前
  $done = false; // 用 done来控制流程流转
  $i = 1 ;
  while ($i < 10 && !$done) {
    echo $i . PHP_EOL;
    if ($i == 5) {
      $done = true;
      continue;
    }
    ++$i;
  }

  // 修改后，可以用编程语言本身的特性去处理
  $i = 1 ;
  while ($i < 10) {
    echo $i . PHP_EOL;
  if ($i == 5) {
      break;
    }
    ++$i;
  }

  ```

### 缩小变量的作用域

> 关键思想：避免全局变量，尽可能缩小变量的作用域，让变量对尽量少的代码可见。

#### 限制作用域

```js
for (var i = 0; i < 10; i++) {
  // todo somthing
}
console.log(i) // 0 ? 10 ?  i is not defined

for (let i = 0; i < 10; i++) {
  // todo somthing
}
console.log(i) // 0 ? 10 ?  i is not defined
```

很多编程语言都提供了多重（局部/全局）作用域/访问级别，比如`js`中的定义局部变量现在更推荐使用`let`,比如面向对象中的类属性/方法的访问级别（`public`、`protected`、`privite`）。通过这些限制，我们可以把变量/类的属性/类的方法，对更少的代码可见。

有时候为了减少一个方法的长度，或者为了满足单一职责原则，而从方法中抽离出来的方法往往作用域是在当前类的内部，最好不要使用`public`关键字

```php
// 文件来源 KeplerProxyV2。php

class KeplerProxyV2
{
     const  CACHE_KEY = 'kepler_access_token';

     const JD_API_HOST = 'https://router.jd.com/api';
     const JD_APP_KEY = 'd34caf8936ad4a1891d1561508216b87';
     const JD_API_FORMAT = 'json';
     const JD_API_VERSION = "1.0";

}

// 其实这些常量只会在当前类中使用，但现在是`public`,在类外也可以访问到，尤其是在使用ide的时候，你输入类名，会自动提示这些常量，很不友好，更改后：

class KeplerProxyV2
{
    private const CACHE_KEY = 'kepler_access_token';

    private const JD_API_HOST = 'https://router.jd.com/api';
    private const JD_APP_KEY = 'd34caf8936ad4a1891d1561508216b87';
    private const JD_API_FORMAT = 'json';
    private const JD_API_VERSION = "1.0";
}

```

#### 把定义变量向下移

就是在用到的时候再去定义该变量，不要在代码一开始就把所有变量放在代码块的顶端。

```php
// 更改前

function viewFilterdReplies(int $original_id) {
    $filtered_replies = [];
    $root_meesage = Meesage::where('id' => $original_id)->first();
    $all_relies = Meesage::where('root_id' => $original_id)->get();

    $root_meesage->view_count +=1;
    $root_meesage->laste_view_time = date('Y-m-d H:i:s');
    $root_meesage->save();

    foreach($all_relies as $reply) {
      if ($reply->spam_votes <= MAX_SPAM_VOTES) {
          $filtered_replies[] = $reply;
      }
    }

    return $filtered_replies;
}


// 更改后
function viewFilterdReplies(int $original_id) {
    $root_meesage = Meesage::where('id' => $original_id)->first();
    $root_meesage->view_count +=1;
    $root_meesage->laste_view_time = date('Y-m-d H:i:s');
    $root_meesage->save();

    $all_relies = Meesage::where('root_id' => $original_id)->get();
    $filtered_replies = [];
    foreach($all_relies as $reply) {
      if ($reply->spam_votes <= MAX_SPAM_VOTES) {
          $filtered_replies[] = $reply;
      }
    }

    return $filtered_replies;
}
```

### 只写一次的变量更好

书中推荐将一些永久固定的变量定义成常量

```php
// 文件来源 fill_mt_price.php

$m = Sku::getInstance();
$total = $m->selectCount(['sync_status' => 2]); // 这中状态类的可以定义成model的常量，在使用的时候直接用常量，如果后期需要将状态变更，就只需要改一个地方，改一次就好了
$limit = 10;
$page = ceil($total / $limit);
$id = 0;
for ($i=0; $i < $page; $i++) {
	echo $id,"\n";
	$rows = $m->select(['sync_status' => 2, 'id' => ['>' => $id]], ['select' => 'id,jd_sku_id,mt_goods_id', 'limit' => $limit]);
	$mtIds = array_column($rows, 'mt_goods_id');
	$mtGoodsList = SkuService::getGoodsInfoBatch($mtIds);
    array_change_v2k($mtGoodsList, 'goods_id');
    foreach ($rows as $row) {
    	$id = $row['id'];
    	$mg = $row['mt_goods_id'];
    	if(!$mg) continue;
    	if(!isset($mtGoodsList[$mg])) {
    		echo "no $mg \n";
    		continue;
    	}
    	echo "update $mg \n";
    	$m->update(['jd_sku_id' => $row['jd_sku_id']], ['mt_price' => $mtGoodsList[$mg]['min_normal_price'], 'mt_state' => $mtGoodsList[$mg]['is_onsale']]);
    }
}

```

### 总结

- 减少`中间结果`产生的变量。
- 减小每个变量的作用域，越小越好。
- 只设置一次值得变量使代码更容易理解。

## 10.抽取不相关的子问题

## 11.一次只做一件事

## 12.把想法变成代码

## 13.少写代码

## 14.测试与可读性

## 15.设计并改进“分钟/小时计数器”
