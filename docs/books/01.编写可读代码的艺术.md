# 编写可读代码的艺术

## 1.代码应当易于理解

## 2.把信息装到名字里

## 3.不会误解的名字

## 4.审美

## 5.该写什么样的注释

## 6.写出言简意赅的注释

## 7.把控制流变得易读

## 8.拆分超长的表达式

## 9.变量与可读性

本章主要讲了三个问题

- 变量越多，就越难全部跟踪他们的动向
- 变量作用域越大，就需要跟踪它的动向越久
- 变量改变的越频繁，就越难跟踪他当前的值

### 减少变量

- 减少没有价值的临时变量

  ```php
  // 文件来源 AfterSaleStep.php

  // 更改前
  public function select($where = [], $attrs = [])
  {
      $use_drds = DBServiceHelper::useDrds();

      if($use_drds) {
          $m = \PT\Service\DBService\Aftersalesteps\Aftersalesteps::getInstance();
          return $m->select($where, $attrs);
      } else {
          return parent::select($where, $attrs);
      }
  }

  // 更改后
  public function select($where = [], $attrs = [])
  {

      if(DBServiceHelper::useDrds()) {
          $m = \PT\Service\DBService\Aftersalesteps\Aftersalesteps::getInstance();
          return $m->select($where, $attrs);
      } else {
          return parent::select($where, $attrs);
      }
  }

  ```

  对于这种没有拆分任何复杂表达式，也没有做更多解释，只用过一次的变量，是没有必要的。

- 减少中间结果

  ```js
  // 更改前
  var remove_one = function(array, value_to_remove) {
    let index_to_remove = null

    for (let i = 0; i < array.length; i++) {
      if (array[i] === value_to_remove) {
        index_to_remove = i
      }
    }
    if (index_to_remove !== null) {
      array.splice(index_to_remove, 1)
    }
  }

  // 更改后
  var remove_one = function(array, value_to_remove) {
    let index_to_remove = null

    for (let i = 0; i < array.length; i++) {
      if (array[i] === value_to_remove) {
        array.splice(i, 1) // 这里不去增加临时变量保存需要删除的index，可以直接处理掉
      }
    }
  }
  ```

- 减少控制流转变量

  ```php

  // 修改前
  $done = false; // 用 done来控制流程流转
  $i = 1 ;
  while ($i < 10 && !$done) {
    echo $i . PHP_EOL;
    if ($i == 5) {
      $done = true;
      continue;
    }
    ++\$i;
  }

  // 修改后，可以用变化才能予以本身的特性去处理
  $i = 1 ;
  while ($i < 10) {
    echo $i . PHP_EOL;
  if ($i == 5) {
      break;
    }
    ++$i;
  }

  ```

### 缩小变量的作用域

> 关键思想：避免全局变量，尽可能缩小变量的作用域，让变量对尽量少的代码可见。

#### 限制作用域

```js
for (var i = 0; i < 10; i++) {
  // todo somthing
}
console.log(i) // 0 ? 10 ?  i is not defined

for (let i = 0; i < 10; i++) {
  // todo somthing
}
console.log(i) // 0 ? 10 ?  i is not defined

```

很多编程语言都提供了多重（局部/全局）作用域/访问级别，比如`js`中的定义局部变量现在更推荐使用`let`,比如面向对象中的类属性/方法的访问级别（`public`、`protected`、`privite`）。通过这些限制，我们可以把变量/类的属性/类的方法，对更少的代码可见。

#### 我们代码中的一些可以优化的点

有时候为了减少一个方法的长度，或者为了满足单一职责原则，而从方法中抽离出来的方法往往作用域是在当前类的内部，最好不要使用`public`关键字

```php
// 文件 ActivitygoodsController

public function beforeDelete($id)
{
    $model = ActivityGoods::getInstance();
    $activity_goods = ActivityGoods::get($id);
    $activity = Activity::get($activity_goods['activity_id']);
    if($activity['type'] == Activity::TYPE_ACTIVITY) {
        Goods::getInstance()->update(['goods_id' => $activity_goods['goods_id']], ['activity_id' => 0]);
        ActionNotifyMQ::getInstance()->goodsChange($activity_goods['goods_id']);
    }

    // TODO
    $this->sort($activity_goods['activity_id']);
    return true;
}

// 这里的sort方法作用域是全局，但其实他只在当前控制器中使用，所以改成 privite 会更好一些
public function sort($act_id)
{
    $sun = ActivityGoods::getInstance()->select([
        'activity_id' => $act_id,
        'status' => 1
    ], [
        'select' => 'id',
        'order_by' => 'rank desc, update_at desc'
    ]);
    $sun = array_reverse($sun);
    foreach($sun as $key => $val) {
        ActivityGoods::getInstance()->update(['id' => $val['id']], ['rank' => $key + 1]);
    }
    $offline = ActivityGoods::getInstance()->select(['activity_id' => $act_id, 'status' => 0]);
    foreach($offline as $item) {
        ActivityGoods::getInstance()->update(['id' => $item['id']], [ 'rank' => 0]);
    }

}
```

```php
// 文件来源 KeplerProxyV2。php

class KeplerProxyV2
{
     const  CACHE_KEY = 'kepler_access_token';

     const JD_API_HOST = 'https://router.jd.com/api';
     const JD_APP_KEY = 'd34caf8936ad4a1891d1561508216b87';
     const JD_API_FORMAT = 'json';
     const JD_API_VERSION = "1.0";

}

// 其实这些常量只会在当前类中使用，但现在是`public`,在类外也可以访问到，尤其是在使用ide的时候，你输入类名，会自动提示这些常量，很不友好，更改后：

class KeplerProxyV2
{
    private const CACHE_KEY = 'kepler_access_token';

    private const JD_API_HOST = 'https://router.jd.com/api';
    private const JD_APP_KEY = 'd34caf8936ad4a1891d1561508216b87';
    private const JD_API_FORMAT = 'json';
    private const JD_API_VERSION = "1.0";
}

```

#### 把定义变量向下移

就是在用到的时候再去定义该变量，不要在代码一开始就把所有变量放在代码块的顶端。

```php
// 文件来源 CostTemplateController

$id = @$GLOBALS['req_id'];
$m = CostTemplate::instance();
$ok = TRUE;  // todo 这里的 $ok 其实是没有意义的，因为下面的ifelse会重新赋值
if (!empty($id)) {
    $am = \PT\Model\Activity::iselect(['is_deleted' => 0, 'status' => 1], ['select' => 'id']);
    $aIds = array_column($am, 'id');
    if($aIds) {
        $gm = Goods::iselect([
            'mall_id' => $this->mallId,
            'cost_template_id' => $id,
            'activity_id' => $aIds,
            'is_onsale' => Goods::IS_ON_SALE_YES,
            'is_deleted' => 0
        ], ['select' => 'goods_id']);
        if($gm) {
            $goodsIds = array_column($gm, 'goods_id');
            return $this->fail(CODE_ERR_DENY, '该运费模板下有商品正在参加活动，暂时不能进行编辑，' . '商品ID:' . implode(', ', $goodsIds));
        }
    }
    $ok = $m->update($GLOBALS['req_id'], $result);
    $this->clearCache($id);
} else {
    $result['mall_id'] = $this->mallId;
    $result['create_at'] = '&/CURRENT_TIMESTAMP';
    $id = $m->insert($result, TRUE);
    $ok = !!$id;
}

```

### 只写一次的变量更好

书中推荐将一些永久固定的变量定义成常量

```php
// 文件来源 fill_mt_price.php

$m = Sku::getInstance();
$total = $m->selectCount(['sync_status' => 2]); // 这中状态类的可以定义成model的常量，在使用的时候直接用常量，如果后期需要将状态变更，就只需要改一个地方，改一次就好了
$limit = 10;
$page = ceil($total / $limit);
$id = 0;
for ($i=0; $i < $page; $i++) {
	echo $id,"\n";
	$rows = $m->select(['sync_status' => 2, 'id' => ['>' => $id]], ['select' => 'id,jd_sku_id,mt_goods_id', 'limit' => $limit]);
	$mtIds = array_column($rows, 'mt_goods_id');
	$mtGoodsList = SkuService::getGoodsInfoBatch($mtIds);
    array_change_v2k($mtGoodsList, 'goods_id');
    foreach ($rows as $row) {
    	$id = $row['id'];
    	$mg = $row['mt_goods_id'];
    	if(!$mg) continue;
    	if(!isset($mtGoodsList[$mg])) {
    		echo "no $mg \n";
    		continue;
    	}
    	echo "update $mg \n";
    	$m->update(['jd_sku_id' => $row['jd_sku_id']], ['mt_price' => $mtGoodsList[$mg]['min_normal_price'], 'mt_state' => $mtGoodsList[$mg]['is_onsale']]);
    }
}

```

### 总结

- 减少`中间结果`产生的变量。
- 减小每个变量的作用域，越小越好。
- 只设置一次值得变量使代码更容易理解。

## 10.抽取不相关的子问题

## 11.一次只做一件事

## 12.把想法变成代码

## 13.少写代码

## 14.测试与可读性

## 15.设计并改进“分钟/小时计数器”
