# 基础知识

## MYSQL

### 索引

> 索引的目的在于提高查询效率

- 唯一索引
- 组合索引
  - 最左前缀原则
    - 组合键的第一个字段必须出现，出可以乱序，否则不会命中索引
    - MySQL 会一直向右匹配，知道遇到（>,<,between,like）就会停止匹配。比如 a = 1 and b = 2 and c > 3 and d = 4, 如果建立（a,b,c,d）顺序的联合索引，d 是用不到的索引，如果建立（a,b,d,c）的索引则都可以用到，且 a,b,d 的顺序可以任意调整。所以当使用组合键作为条件时一定要将比较运算符放在最后。
- 主键索引
- 全文索引

### 提高 SQL 查询效率需要注意的点

- 列字段有 `null` 值，索引会失效，列最好加 `not null` 和 `default value`
- `not in`,`<>`, `!=` 索引会失效
- 查询条件中有 `or` 如果有的列没加索引，不会命中索引

  > 如: `select * from orders where id = 100 or user_id = 123`,当 `id` 有主键索引，而 `user_id` 没有索引时，不会命中索引。如果想命中索引，要给 `where` 条件的每个列都加上索引。

- `like` 的模糊查询以 `%` 开头，索引失效
- 如果字段类型是字符串，查询条件中药将数据使用引号引用起来，否则索引失效

  > 如： `select * from users where mobile = '18888888888'` , `mobile` 字段在查询时需要加引号，否则不会命中索引

- `where` 条件子句中使用了函数，无法使用索引
- 如果 `MySQL` 预计使用全表扫描要比使用索引快，则不使用索引

### 分析慢查询 `Explain` 的使用

#### `explain` 后比较重要的几个字段

- select_type

  表示查询类型，常用的取值有：

  - SIMPLE : 表示此查询不包含 `UNION` 查询或子查询
  - PRIMARY : 表示此查询是最外层的查询
  - UNION : 表示此查询是 `UNION` 的第二查询

- table

  表示查询涉及的表或衍生表

- type

  通过 `type` 字段可以判断此次是`全表扫描`还是`索引扫描`

  - system： 表中只有一条数据
  - const：
  - eq_ref：此类型通常出现在多表的 `join` 查询
  - ref：通常出现在多表的 `join` 查询，针对非唯一或非主键原则，护着使用了最左前缀原则
  - range：表示使用索引范围查询，通过索引字段范围获取表中部署数据记录
  - index：表示全索引扫描，和 `ALL` 类似，这个仅仅扫描全部索引
  - ALL：表示全表扫描，这个类型的查询时性能最差的查询之一

  type 类型的性能对比：ALL < index < range < ref < eq_ref < const < system

- possible_keys

  表示在查询时, 能够使用到的索引. 注意, 即使有些索引在 `possible_keys` 中出现, 但是并不表示此索引会真正地被 `MySQL` 使用到。 `MySQL` 在查询时具体使用了哪些索引, 由 `key` 字段决定.

- key

  此字段是 `MySQL` 在当前查询时所真正使用到的索引.

- rows

  估算 `SQL` 要查找到结果集需要扫描读取的数据行数。这个值非常直观显示 `SQL` 的效率好坏, 原则上 `rows` 越少越好

## TCP/IP HTTP

TCP 是面向连接的通讯协议，简历会话过程如下：

- 请求一个面向连接的通信会话
- 建立会话
- 传输数据
- 传输结束，信道解除连接

### 三次握手，四次挥手

> TODO...

## 分布式

## PHP

## Opcache

### PHP-FPM + Nginx 的工作机制

- 启动 PHP-FPM 服务 + Nginx 服务

  > 启动 PHP-FPM 会启动两种类型的进程： Master 主进程和 Worker（cgi 进程） 子进程。Master 进程负责监控端口、分配任务，管理 Worker 进程。Worker 进程就是 PHP 的 CGI 程序，负责解释编译执行 PHP 脚本。

  > 启动 Nginx : 首先会载入 `ngx_http_fastcgi_module` 模块，初始化 FastCGI 执行环境，实现 FastCGI 执行环境，实现 FastCGI 协议请求代理。

- 请求 -> Nginx

  > Nginx 接收请求，并基于 `location` 配置，选择一个合适的 handler

- Nginx -> PHP-FPM Master 进程

  > Nginx 通过 TCP socket/Unix Socket 把请求转发给 PHP-FPM Master 进程

- PHP-FPM Master 进程 -> PHP-FPM Worker 子进程

  > PHP-FPM Master 进程接收到请求，分配给 Worker 进程执行 PHP 脚本，如果没有空闲的 Worker 返回 502 错误。 Worker 进程执行 PHP 脚本,如果执行超时，返回 504 错误。处理完成，返回结果

- 返回处理结果：PHP-FPM Worker 子进程 -> PHP-FPM Matser 主进程 -> Nginx

  - Worker 子进程 返回处理结果，关闭连接，等待下一个请求
  - Master 进程通过 Socket 返回处理结果
  - Nginx Handler 顺序将每一个响应发送给客户端

## VueJs

## 接口幂等

- 幂等概念
  - 保证唯一
- 产生原因
  - rpc 调用时网络延迟（重试发送请求）
  - 表单重复提交

幂等性是系统的接口对外的一种承诺，而不是实现。承诺只要调用接口成功，外部多次调用对系统的影响是一致的，声明为幂等的接口会认为外部调用失败是常态，并且失败之后必然会有重试。

有些接口是天然实现幂等性的，比如查询接口。对于查询接口，你查询一次和两次，对于系统来说没有任何影响，查出的结果是一样的。

### 对增加、删除、更新操作做幂等处理

- 全局唯一 id

根据业务和操作的内容生成一个全局 id，在执行操作以先判断存储系统中是否存在这个全局 id 来判断这个操作是否已经执行。如果不存在则把全局 id，存到存储系统中，如果存在则表示该操作已经执行。

高可靠的幂等服务。

- 去重表

新建一张去重表（唯一键），在接口操作数据的事务中增加将唯一标识（比如订单 id）写入去重表，如果重复创建数据库会跑出唯一约束异常，操作就会回滚。

比如在支付场景中，如果一个订单只会支付一次，所以订单 ID 可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和订单号写入去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。

- 插入或更新

通过数据库唯一键，实现 createOrUpdate 操作

## WEB 安全

### 防流量攻击

### 接口防刷

### SQL 注入

#### 什么是 sql 注入

通过把 sql 命令插入到 web 表单提交或输入域名或页面请求查询字符串，最终达到欺骗服务器执行恶意的 Sql 命令。

#### 预防 SQL 注入

- 永远不要使用超级用户或所有者账号去连接数据库，严格限制账号权限。
- 检查输入的数据是否是所期望的数据格式或类型。
- 使用数据库特定的敏感字符转义函数，把用户提交的非数字数据进行转义
  - addslashes(),str_replace(),mysql_real_escape_string()
- 使用 PDO，预处理，绑定参数
  - prepare 语句后，绑定参数是和编译过的语句结合，而非 SQL 字符串结合。SQL 注入的原理就是混淆参数和语句
- 生产环境关闭 Debug 模式，避免将错误的 SQL 语句打印输出

### XSS 攻击（跨站脚本）

#### 避免

- 对任何用户输入的信息，入库前都进行转义
- 使用浏览器自带的 xss filter
- 使用 HttpOnly 保护 cookie

### CSRF

#### 避免策略

- 阻止不明外域访问
  - 同源检测
- 提交时要求附加本域才能获取的信息
  - csrf token
