# 基础知识

## MYSQL

### 索引

> 索引的目的在于提高查询效率

- 唯一索引
- 组合索引
  - 最左前缀原则
    - 组合键的第一个字段必须出现，出可以乱序，否则不会命中索引
    - MySQL 会一直向右匹配，知道遇到（>,<,between,like）就会停止匹配。比如 a = 1 and b = 2 and c > 3 and d = 4, 如果建立（a,b,c,d）顺序的联合索引，d 是用不到的索引，如果建立（a,b,d,c）的索引则都可以用到，且 a,b,d 的顺序可以任意调整。所以当使用组合键作为条件时一定要将比较运算符放在最后。
- 主键索引
- 全文索引

### 提高 SQL 查询效率需要注意的点

- 列字段有 `null` 值，索引会失效，列最好加 `not null` 和 `default value`
- `not in`,`<>`, `!=` 索引会失效
- 查询条件中有 `or` 如果有的列没加索引，不会命中索引

  > 如: `select * from orders where id = 100 or user_id = 123`,当 `id` 有主键索引，而 `user_id` 没有索引时，不会命中索引。如果想命中索引，要给 `where` 条件的每个列都加上索引。

- `like` 的模糊查询以 `%` 开头，索引失效
- 如果字段类型是字符串，查询条件中药将数据使用引号引用起来，否则索引失效

  > 如： `select * from users where mobile = '18888888888'` , `mobile` 字段在查询时需要加引号，否则不会命中索引

- `where` 条件子句中使用了函数，无法使用索引
- 如果 `MySQL` 预计使用全表扫描要比使用索引快，则不使用索引

### 分析慢查询 `Explain` 的使用

#### `explain` 后比较重要的几个字段

- select_type

  表示查询类型，常用的取值有：

  - SIMPLE : 表示此查询不包含 `UNION` 查询或子查询
  - PRIMARY : 表示此查询是最外层的查询
  - UNION : 表示此查询是 `UNION` 的第二查询

- table

  表示查询涉及的表或衍生表

- type

  通过 `type` 字段可以判断此次是`全表扫描`还是`索引扫描`

  - system： 表中只有一条数据
  - const：
  - eq_ref：此类型通常出现在多表的 `join` 查询
  - ref：通常出现在多表的 `join` 查询，针对非唯一或非主键原则，护着使用了最左前缀原则
  - range：表示使用索引范围查询，通过索引字段范围获取表中部署数据记录
  - index：表示全索引扫描，和 `ALL` 类似，这个仅仅扫描全部索引
  - ALL：表示全表扫描，这个类型的查询时性能最差的查询之一

  type 类型的性能对比：ALL < index < range < ref < eq_ref < const < system

- possible_keys

  表示在查询时, 能够使用到的索引. 注意, 即使有些索引在 `possible_keys` 中出现, 但是并不表示此索引会真正地被 `MySQL` 使用到。 `MySQL` 在查询时具体使用了哪些索引, 由 `key` 字段决定.

- key

  此字段是 `MySQL` 在当前查询时所真正使用到的索引.

- rows

  估算 `SQL` 要查找到结果集需要扫描读取的数据行数。这个值非常直观显示 `SQL` 的效率好坏, 原则上 `rows` 越少越好

## TCP/IP HTTP

TCP 是面向连接的通讯协议，简历会话过程如下：

- 请求一个面向连接的通信会话
- 建立会话
- 传输数据
- 传输结束，信道解除连接

### 三次握手，四次挥手

> TODO...

## WEB 安全

## 分布式

## PHP

## Opcache

### PHP-FPM + Nginx 的工作机制

- 启动 PHP-FPM 服务 + Nginx 服务

  > 启动 PHP-FPM 会启动两种类型的进程： Master 主进程和 Worker（cgi进程） 子进程。Master 进程负责监控端口、分配任务，管理 Worker 进程。Worker 进程就是 PHP 的 CGI 程序，负责解释编译执行 PHP 脚本。

  > 启动 Nginx : 首先会载入 `ngx_http_fastcgi_module` 模块，初始化 FastCGI 执行环境，实现 FastCGI 执行环境，实现 FastCGI 协议请求代理。

- 请求 -> Nginx

  > Nginx 接收请求，并基于 `location` 配置，选择一个合适的 handler

- Nginx -> PHP-FPM Master 进程

  > Nginx 通过 TCP socket/Unix Socket 把请求转发给 PHP-FPM Master 进程

- PHP-FPM Master 进程 -> PHP-FPM Worker 子进程

  > PHP-FPM Master 进程接收到请求，分配给 Worker 进程执行 PHP 脚本，如果没有空闲的 Worker 返回 502 错误。 Worker 进程执行 PHP 脚本,如果执行超时，返回 504 错误。处理完成，返回结果

- 返回处理结果：PHP-FPM Worker 子进程 -> PHP-FPM Matser 主进程 -> Nginx

  - Worker 子进程 返回处理结果，关闭连接，等待下一个请求
  - Master 进程通过 Socket 返回处理结果
  - Nginx Handler 顺序将每一个响应发送给客户端

## VueJs
