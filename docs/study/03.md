# 基础知识

## MYSQL

### 索引

> 索引的目的在于提高查询效率

- 唯一索引
- 组合索引
  - 最左前缀原则
    - 组合键的第一个字段必须出现，出可以乱序，否则不会命中索引
    - MySQL 会一直向右匹配，知道遇到（>,<,between,like）就会停止匹配。比如 a = 1 and b = 2 and c > 3 and d = 4, 如果建立（a,b,c,d）顺序的联合索引，d 是用不到的索引，如果建立（a,b,d,c）的索引则都可以用到，且 a,b,d 的顺序可以任意调整。所以当使用组合键作为条件时一定要将比较运算符放在最后。
- 主键索引
- 全文索引

### 提高 SQL 查询效率需要注意的点

- 列字段有 `null` 值，索引会失效，列最好加 `not null` 和 `default value`
- `not in`,`<>`, `!=` 索引会失效
- 查询条件中有 `or` 如果有的列没加索引，不会命中索引

  > 如: `select * from orders where id = 100 or user_id = 123`,当 `id` 有主键索引，而 `user_id` 没有索引时，不会命中索引。如果想命中索引，要给 `where` 条件的每个列都加上索引。

- `like` 的模糊查询以 `%` 开头，索引失效
- 如果字段类型是字符串，查询条件中药将数据使用引号引用起来，否则索引失效

  > 如： `select * from users where mobile = '18888888888'` , `mobile` 字段在查询时需要加引号，否则不会命中索引

- `where` 条件子句中使用了函数，无法使用索引
- 如果 `MySQL` 预计使用全表扫描要比使用索引快，则不使用索引

### 分析慢查询 `Explain` 的使用

#### `explain` 后比较重要的几个字段

- select_type

  表示查询类型，常用的取值有：

  - SIMPLE : 表示此查询不包含 `UNION` 查询或子查询
  - PRIMARY : 表示此查询是最外层的查询
  - UNION : 表示此查询是 `UNION` 的第二查询

- table

  表示查询涉及的表或衍生表

- type

  通过 `type` 字段可以判断此次是`全表扫描`还是`索引扫描`

  - system： 表中只有一条数据
  - const：
  - eq_ref：此类型通常出现在多表的 `join` 查询
  - ref：通常出现在多表的 `join` 查询，针对非唯一或非主键原则，护着使用了最左前缀原则
  - range：表示使用索引范围查询，通过索引字段范围获取表中部署数据记录
  - index：表示全索引扫描，和 `ALL` 类似，这个仅仅扫描全部索引
  - ALL：表示全表扫描，这个类型的查询时性能最差的查询之一

  type 类型的性能对比：ALL < index < range < ref < eq_ref < const < system

- possible_keys

  表示在查询时, 能够使用到的索引. 注意, 即使有些索引在 `possible_keys` 中出现, 但是并不表示此索引会真正地被 `MySQL` 使用到。 `MySQL` 在查询时具体使用了哪些索引, 由 `key` 字段决定.

- key

  此字段是 `MySQL` 在当前查询时所真正使用到的索引.

- rows

  估算 `SQL` 要查找到结果集需要扫描读取的数据行数。这个值非常直观显示 `SQL` 的效率好坏, 原则上 `rows` 越少越好

### MySQL 索引及 B+树

- 为什么加索引能优化查询？

索引是一种优化查询的数据结构，MySQL中的索引是使用`B+树`的数据结构实现的，`B+树`可以优化查询速度。所以在MySQL中可以使用索引优化查询速度。

- 为什么`MySQL`使用`B+树`

  - B+树的非叶子结点只存储索引值和指针，不存储数据
    - 在磁盘中每页容量大小固定,如果存储数据就会导致存储的键（索引值）少，导致树高，树的高度会影响I/O开销，也就影响索引的查找效率。

  - MySQL 索引使用 B+树的数据结构存储`索引`数据

- MyISAM 和 InnoDB 索引存储的方式
  
  - MyISAM
    - MyISAM 叶子节点存储的是表的一行数据对应的地址
  - InnoDB
    - 主键索引叶子节点存的是当前行的数据
    - 非主键索引叶子节点存的是当前行的主键索引

### Mysql 分表

> TODO

### Mysql 锁

> TODO

## TCP/IP HTTP

TCP 是面向连接的通讯协议，简历会话过程如下：

- 请求一个面向连接的通信会话
- 建立会话
- 传输数据
- 传输结束，信道解除连接

### 三次握手，四次挥手

> TODO...

## PHP

- array_merge 和 + 的区别

  - `+` 既考虑数字索引的键值对,也考虑字符串索引的键值对, 用前边数组的值覆盖后边的键名相同的值
  - array_merge 只考虑字符串索引的键值对, 用后边数组的值覆盖掉前面数组中键名相同的值，数字索引的值则不覆盖,同时保留,重建索引

- PHP7 新特性

  - 空合并操作符 ??
  - Throwable
  - 一次捕捉多种类型的异常 / 错误 PHP 7.1 新添加了捕获多种异常/错误类型的语法通过竖杠“|”来实现。
  - 性能提升了两倍
  - 标量类型声明
  - 返回类型声明
  - 为什么 PHP7 比 PHP5 性能提升了
    - 变量存储字节减小，减少内存占用，提升变量操作速度
    - 改善数组结构，数组元素和 hash 映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率
    - 改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率

- composer

  composer 是 PHP 的一个依赖管理工具。工作原理就是将已开发好的扩展包从 packagist.org composer 仓库下载到我们的应用程序中，并声明依赖关系和版本控制。

  自动加载规范 PSR-4 PSR-0 classmap file
  PSR-1 PSR-2 编码风格规范
  PSR-3 日志记录器接口
  PSR-6 缓存接口规范
  PSR-7 缓存接口规范

- 设计模式

  - 单例
    - 设计模式之单例模式
    - \$\_instance 必须声明为静态的私有变量
    - 构造函数和析构函数必须声明为私有,防止外部程序 new
    - 类从而失去单例模式的意义
    - getInstance()方法必须设置为公有的,必须调用此方法
    - 以返回实例的一个引用
    - ::操作符只能访问静态变量和静态函数
    - new 对象都会消耗内存
    - 使用场景:最常用的地方是数据库连接。
    - 使用单例模式生成一个对象后，
    - 该对象可以被其它众多对象所使用。
  - 工厂
    - 工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来
    - 根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想
  - 观察者
    - 定义：当一个对象状态发生改变时，依赖他的对象全部得到通知
    - 优点：低耦合、非侵入式

- 基本函数

  - 你知道哪些 PHP 自带的数组排序方法？
    - sort() 函数用于对数组单元从低到高进行排序。
    - rsort() 函数用于对数组单元从高到低进行排序。
    - asort() 函数用于对数组单元从低到高进行排序并保持索引关系。
    - arsort() 函数用于对数组单元从高到低进行排序并保持索引关系。
    - ksort() 函数用于对数组单元按照键名从低到高进行排序。
    - krsort() 函数用于对数组单元按照键名从高到低进行排序。

- 排序算法

  - 冒泡

    ```php
      /**
       * 冒泡排序 时间复杂度 O(n^2)
       */
      function bubbleSort(array $a){

        $len = count($a);

        for ($i=0; $i < $len; $i++) {
          for ($j=0; $j < $len-$i-1; $j++) {
            if($a[$j+1] < $a[$j]){
              $temp = $a[$j+1];
              $a[$j+1] = $a[$j];
              $a[$j] = $temp;
            }
          }
        }

        return $a;
      }
    ```

  - 快排

    ```php
     /**
      * 快速排序 最差时间复杂度O(N^2)，平均时间复杂度为O(NlogN)
      */
      function quickSort(array $a){

        $len =  count($a);

        if($len <= 1){
          return $a;
        }

        $pivot = $a[0];

        $left = $right = [];

        for ($i=1; $i < $len; $i++) {
          if($a[$i] < $pivot){
            $left[] = $a[$i];
          }else {
            $right[] = $a[$i];
          }
        }

        $left = quickSort($left);
        $right = quickSort($right);

        return array_merge($left,[$pivot],$right);
      }
    ```

  - 选择

    ```php
       /**
        * @param 选择排序法
        * 每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完
        *
        */
    ```

  - 插入

    ```php
     /**
      * 插入排序法
      * 每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。
      *
      */
    ```

### Laravel

- Laravel IOC ServiceProvider

  服务提供者是所有 Laravel 应用程序引导启动的中心, Laravel 的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。

  IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。
  其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。

  依赖注入只是一种模式：把当前类依赖的第三方实例通过参数传入的形式引入，但是如果手写依赖注入会比较费劲，管理起来也比较麻烦，因为要关心那么多类的依赖，于是就有了一个容器来自动解决这个问题，利用反射 API 检查类型，然后递归解决依赖。

### Swoole

> TODO

### Opcache

#### PHP-FPM + Nginx 的工作机制

- 启动 PHP-FPM 服务 + Nginx 服务

  > 启动 PHP-FPM 会启动两种类型的进程： Master 主进程和 Worker（cgi 进程） 子进程。Master 进程负责监控端口、分配任务，管理 Worker 进程。Worker 进程就是 PHP 的 CGI 程序，负责解释编译执行 PHP 脚本。

  > 启动 Nginx : 首先会载入 `ngx_http_fastcgi_module` 模块，初始化 FastCGI 执行环境，实现 FastCGI 执行环境，实现 FastCGI 协议请求代理。

- 请求 -> Nginx

  > Nginx 接收请求，并基于 `location` 配置，选择一个合适的 handler

- Nginx -> PHP-FPM Master 进程

  > Nginx 通过 TCP socket/Unix Socket 把请求转发给 PHP-FPM Master 进程

- PHP-FPM Master 进程 -> PHP-FPM Worker 子进程

  > PHP-FPM Master 进程接收到请求，分配给 Worker 进程执行 PHP 脚本，如果没有空闲的 Worker 返回 502 错误。 Worker 进程执行 PHP 脚本,如果执行超时，返回 504 错误。处理完成，返回结果

- 返回处理结果：PHP-FPM Worker 子进程 -> PHP-FPM Matser 主进程 -> Nginx

  - Worker 子进程 返回处理结果，关闭连接，等待下一个请求
  - Master 进程通过 Socket 返回处理结果
  - Nginx Handler 顺序将每一个响应发送给客户端

## VueJs

- Vue 双向数据绑定原理

  Object.defindproperty:数据劫持，结合发布-订阅模式
  Object.defindproperty 劫持各个属性的 setter 和 getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

## 接口安全处理

### 并发

### 接口幂等

- 幂等概念
  - 保证唯一
- 产生原因
  - rpc 调用时网络延迟（重试发送请求）
  - 表单重复提交

幂等性是系统的接口对外的一种承诺，而不是实现。承诺只要调用接口成功，外部多次调用对系统的影响是一致的，声明为幂等的接口会认为外部调用失败是常态，并且失败之后必然会有重试。

有些接口是天然实现幂等性的，比如查询接口。对于查询接口，你查询一次和两次，对于系统来说没有任何影响，查出的结果是一样的。

#### 对增加、删除、更新操作做幂等处理

- 全局唯一 id

根据业务和操作的内容生成一个全局 id，在执行操作以先判断存储系统中是否存在这个全局 id 来判断这个操作是否已经执行。如果不存在则把全局 id，存到存储系统中，如果存在则表示该操作已经执行。

高可靠的幂等服务。

- 去重表

新建一张去重表（唯一键），在接口操作数据的事务中增加将唯一标识（比如订单 id）写入去重表，如果重复创建数据库会跑出唯一约束异常，操作就会回滚。

比如在支付场景中，如果一个订单只会支付一次，所以订单 ID 可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和订单号写入去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。

- 插入或更新

通过数据库唯一键，实现 createOrUpdate 操作

### 接口防刷

- 直接拒接访问
  - 验证码
    - 图像验证码
    - 滑块
    - 找不同
  - 设置接口请求频率百日每分钟 20 次，超过返回频繁操作
  - 对单个用户/IP 限制每分钟请求次数
  - 对敏感词/广告进行过滤
- 重放攻击
  - timestamp + 随机字符串
  - 前端请求带时间戳，和服务端对比，相差一分钟算作作弊
- 签名参数 sign 生成的方法
  - 第 1 步: 将所有参数（注意是所有参数），除去 sign 本身，以及值是空的参数，按参数名字母升序排序。
  - 第 2 步: 然后把排序后的参数按参数 1 值 1 参数 2 值 2…参数 n 值 n（这里的参数和值必须是传输参数的原始值，不能是经过处理的，如不能将&quot;转成”后再拼接）的方式拼接成一个字符串。
  - 第 3 步: 把分配给接入方的验证密钥 key 拼接在第 2 步得到的字符串前面。
  - 第 4 步: 计算第 3 步字符串的 md5 值(32 位)，然后转成大写,得到的字符串作为 sign 的值。
- 签名算法规则
  - 时间戳，随机数，口令按照首字母大小写顺序排序
  - 然后拼接成字符串
  - 进行 sha1 加密
  - 再进行 MD5 加密
  - 转换成大写。

## WEB 安全

### SQL 注入

#### 什么是 SQL 注入

通过把 sql 命令插入到 web 表单提交或输入域名或页面请求查询字符串，最终达到欺骗服务器执行恶意的 Sql 命令。

#### 怎么实现 SQL 注入

> TODO

#### 预防 SQL 注入

- 永远不要使用超级用户或所有者账号去连接数据库，严格限制账号权限。
- 检查输入的数据是否是所期望的数据格式或类型。
- 使用数据库特定的敏感字符转义函数，把用户提交的非数字数据进行转义
  - addslashes(),str_replace(),mysql_real_escape_string()
- 使用 PDO，预处理，绑定参数
  - prepare 语句后，绑定参数是和编译过的语句结合，而非 SQL 字符串结合。SQL 注入的原理就是混淆参数和语句
- 生产环境关闭 Debug 模式，避免将错误的 SQL 语句打印输出

### XSS 攻击（跨站脚本）

#### 怎么实现

> TODO

#### 避免

- 对任何用户输入的信息，入库前都进行转义
- 使用浏览器自带的 xss filter
- 使用 HttpOnly 保护 cookie

### CSRF(跨站请求伪造)

#### 怎么实现CSRF

> TODO

#### 避免策略

- 阻止不明外域访问
  - 同源检测
- 提交时要求附加本域才能获取的信息
  - csrf token

## Redis

- Redis 类型，使用场景

  Redis 支持更加丰富的数据存储类型，String、Hash、List、Set 和 Sorted Set。Memcached 仅支持简单的 key-value 结构。

  - String：key=>value set get decr incr
  - Hash: 存放结构化数据 hset hget hgetall
  - List: 消息队列、列表 lpush rpush lpop rpop lrange
  - Set: 不重复的无序集合，某些需要去重的列表 sadd spop smembers
  - Sorted Set 有序集合，比 set 多分数，根据分数自懂排序 zadd zrange zrem zcard

- Redis 如何实现持久化？

  - RDB 持久化，将 redis 在内存中的的状态保存到硬盘中，相当于备份数据库状态。

  - AOF 持久化（Append-Only-File），AOF 持久化是通过保存 Redis 服务器锁执行的写状态来记录数据库的。相当于备份数据库接收到的命令，所有被写入 AOF 的命令都是以 redis 的协议格式来保存的。

## 缓存

> TODO

## Linux

> TODO

### Nginx 编译配置

> TODO

### PHP编译配置

> TODO